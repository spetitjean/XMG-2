import os, sys, glob, xmg.command

class BrickCompiler(object):

    def __init__(self, folder=None, parser_file=None):
        self._folder     = folder
        self._parser_file= parser_file
        self._languages  = []
        self._compilers  = []
        self._dimensions = [('trace','trace')]
        self._links      = []
        self._punctuation= []
        self._keywords   = []
        self._solvers    = dict()
        self._tags       = dict()

    def set_folder(self,folder):
        self._folder=folder

    def set_parser_file(self,path):
        self._parser_file=path

    def add_language(self,lang):
        self._languages.append(lang)
  

    def add_languages(self,langs):
        for lang in langs:
            self.add_language(lang)
        

    def add_compiler(self,comp):
        #print(self._compilers)
        if comp in self._compilers:
            pass
        else:
            # add dependencies
            yapdir=xmg.config['DEFAULT']['xmg_yap_rootdir']
            deppath=yapdir+"/"+comp+"/compiler/deps"
            if(os.path.exists(deppath)):
                depfile=open(deppath,"r")
                for line in depfile.read().splitlines():
                    print("\nAdding dependency:")
                    print(line)
                    self.add_compiler("xmg/brick/"+line)
            basename = os.path.basename(comp)
            if basename== "mg":
                self._compilers.insert(0,comp)
            elif basename== "dim":
                position=0
                if len(self._compilers) > 0:
                    if(os.path.basename(self._compilers[0]))=="mg":
                        position=1
                self._compilers.insert(position,comp)
            else:
                self._compilers.append(comp)

    def add_compilers(self,comps):
        for comp in comps:
            self.add_compiler(comp)
        

    def add_link(self,language,compiler):
        if not language in self._languages:
            raise Exception("Brick "+language._prefix+" is not part of the compiler, try one of "+self._languages)
        if not compiler in self._compilers:
            raise Exception("Brick "+compiler+" is not part of the compiler")
        self._links.append((language,compiler))
    

    def add_links(self,links):
        for (language,compiler) in links:
            self.add_link(language,compiler)

    def add_brick(self,brick,dim=False):
        self.add_language(brick.language_brick)
        self.add_compiler(brick.compiler_brick)
        self.add_link(brick.language_brick,brick.compiler_brick)
        if brick._solver is not None:
            self._solvers[brick._prefix]=brick._solver
        if brick._tag is not None:
            self._tags[brick._prefix]=brick._tag
        if dim:
            self._dimensions.append((brick._tag,brick._dimbrick))
 

    def generate_dimensions(self):
        dimfile=open(self._folder+"/dimensions.yap","w")
        dimfile.write('%% -*- prolog -*-\n\n')
        dimfile.write(':-module(xmg_dimensions).\n\n')
        dimfile.write('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n')
        dimfile.write('%% Dimensions initialization\n')
        dimfile.write('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n')

        for (dim,dimbrick) in self._dimensions:
            dimfile.write('xmg:dimbrick(')
            dimfile.write(dim)
            dimfile.write(',')
            dimfile.write(dimbrick)
            dimfile.write(').\n')
            
        dimfile.close()
        print("Dimensions generated in %s/dimensions.yap"%self._folder)

    def generate_solvers(self):
        dimfile=open(self._folder+"/solvers.yap","w")
        dimfile.write('%% -*- prolog -*-\n\n')
        dimfile.write(':-module(xmg_solvers).\n\n')
        dimfile.write('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n')
        dimfile.write('%% Solvers bindings to dimensions\n')
        dimfile.write('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n')

        if not self._solvers:
            dimfile.write('xmg:solver(_,_):- false.\n')
        for solver in self._solvers:
            dimfile.write('xmg:solver(')
            dimfile.write(self._tags[solver])
            dimfile.write(',')
            dimfile.write(self._solvers[solver])
            dimfile.write(').\n')
            # add plugin dependencies
            yapdir=xmg.config['DEFAULT']['xmg_yap_rootdir']
            deppath=yapdir+"/xmg/brick/"+self._solvers[solver]+"/compiler/deps"
            print("Solver dep: "+deppath)
            if(os.path.exists(deppath)):
                print("Exists")
                depfile=open(deppath,"r")
                for line in depfile.read().splitlines():
                    print("\nAdding plugin dependency:")
                    print(line)
                    self.add_compiler("xmg/brick/"+line)
        dimfile.close()
        print("Solvers bindings generated in %s/solvers.yap"%self._folder)

    def generate_edcg(self):
        dimfile=open(self._folder+"/edcg.yap","w")
        dimfile.write('%% -*- prolog -*-\n\n')
        dimfile.write(':-module(xmg_edcg).\n\n')
        dimfile.write(':-xmg:edcg.\n\n')
        dimfile.write('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n')
        dimfile.write('%% Threads initialization\n')
        dimfile.write('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n')
        
        dimsp=[]
        accs=[]
        accspairs=[]
        accs_init=[]
        for (dim,dimbrick) in self._dimensions:
            dimsp.append(dim+"-"+str.capitalize(dim))
            accs.append('xmg_acc:%s' % dim)
            accspairs.append('')
            accs_init.append('xmg_acc:%s(%s)' % (dim,str.capitalize(dim)))



        for (dim,dimbrick) in self._dimensions:
            import xmg
            yapdir=xmg.config['DEFAULT']['xmg_yap_rootdir']
            if os.path.exists(yapdir+'/xmg/brick/'+dimbrick+'/compiler/edcg.yap'):
                dimfile.write(':-edcg:thread(xmg_acc:'+dim+', xmg_brick_'+dimbrick+'_edcg:accu_type).\n\n')
            else:
                dimfile.write(':-edcg:thread(xmg_acc:'+dim+', edcg:stack).\n\n')

        #dimfile.write(':-edcg:thread(xmg_acc:trace, edcg:stack).\n\n')
        dimfile.write(':-edcg:weave(['+", ".join(accs)+'],[xmg:value_class/3]).\n\n')
        dimfile.write('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n')
        dimfile.write('%% Starting valuation\n')
        dimfile.write('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n')

        accs=", ".join(dimsp)

        dimfile.write('xmg:start_value_class(Class,['+accs+']):--\n')
        dimfile.write('  xmg:value_class(Class,_,_) with ('+", ".join(accs_init))
        dimfile.write(').')

        print("Threads generated in %s/edcg.yap"%self._folder)
        dimfile.close()


    def collect_punctuation(self):
        for lang in self._languages:
            for npunct in lang._punctuation:
                if npunct not in self._punctuation and npunct > '':
                    self._punctuation.append(npunct)
        self._punctuation.sort(reverse=True)

    def collect_keywords(self):
        for lang in self._languages:
            for nkey in lang._keywords:
                if nkey not in self._keywords and nkey > '':
                    self._keywords.append(nkey)
        self._keywords.sort(reverse=True)


    def generate_tokenize_punctuation(self):
        self.collect_punctuation()
        tokenizefile=open(self._folder+"/tokenizer_punct.yap","w")
        tokenizefile.write('%% -*- prolog -*-\n\n')
        tokenizefile.write(':-module(xmg_tokenizer_punct).\n\n')
        tokenizefile.write('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n')
        tokenizefile.write('%% Part of tokenizer\n')
        tokenizefile.write('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n')
        if not self._punctuation:
            tokenizefile.write('xmg:punctuation(_):- false.\n')

        
        for punct in self._punctuation:
            #tokenizefile.write('punctuation(\''+punct+'\') -->> input_gets("'+punct+'"), !.\n')
            tokenizefile.write('xmg:punctuation(\''+punct+'\').\n')

        tokenizefile.close()
        print("Part of tokenizer generated in %s/tokenizer_punct.yap"%self._folder)

    def generate_tokenize_keywords(self):
        self.collect_keywords()
        tokenizefile=open(self._folder+"/tokenizer_keywords.yap","w")
        tokenizefile.write('%% -*- prolog -*-\n\n')
        tokenizefile.write(':-module(xmg_tokenizer_keywords).\n\n')
        tokenizefile.write('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n')
        tokenizefile.write('%% Part of tokenizer\n')
        tokenizefile.write('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n')
        if not self._keywords:
            tokenizefile.write('xmg:keyword(_):- false.\n')

        
        for key in self._keywords:
            #tokenizefile.write('punctuation(\''+punct+'\') -->> input_gets("'+punct+'"), !.\n')
            tokenizefile.write('xmg:keyword(\''+key+'\').\n')

        tokenizefile.close()
        print("Part of tokenizer generated in %s/tokenizer_keywords.yap"%self._folder)

    def generate_loader(self):
        compfile=open(self._folder+"/loader.yap","w")
        compfile.write('%% -*- prolog -*-\n\n')
        compfile.write(':-module(xmg_loader).\n\n')
        compfile.write('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n')
        compfile.write('%% Loader\n')
        compfile.write('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n') 
        import glob
        yapdir= xmg.command.YAPDIR 
        for comp in self._compilers:  
            for yapfile in glob.glob("%s/%s/*.yap" % (yapdir,comp)):
                compfile.write(':-use_module(\'%s\').\n' % yapfile)
            yapfiles=glob.glob("%s/%s/compiler/*.yap" % (yapdir,comp))
            yapfiles.sort()
            for yapfile in yapfiles:
                # if a loader is there, do not load it, to avoid double imports
                if not os.path.basename(yapfile)=="loader.yap": 
                    compfile.write(':-use_module(\'%s\').\n' % yapfile)
        for solver in self._solvers:
            for yapfile in glob.glob("%s/xmg/brick/%s/*.yap" % (yapdir,self._solvers[solver])):
                compfile.write(':-use_module(\'%s\').\n' % yapfile)
            for yapfile in glob.glob("%s/xmg/brick/%s/compiler/*.yap" % (yapdir,self._solvers[solver])):
                 # if a loader is there, do not load it, to avoid double imports
                if not os.path.basename(yapfile)=="loader.yap": 
                    compfile.write(':-use_module(\'%s\').\n' % yapfile)
        print("Modules loader generated in %s/loader.yap"%self._folder)

    def generate_silent_loader(self):
        compfile=open(self._folder+"/loader.yap","w")
        compfile.write('%% -*- prolog -*-\n\n')
        compfile.write(':-module(xmg_loader).\n\n')
        compfile.write('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n')
        compfile.write('%% Loader\n')
        compfile.write('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n') 
        import glob
        yapdir= xmg.command.YAPDIR 
        # compfile.write(':-load_files([')
        files=[]
        for comp in self._compilers:  
            for yapfile in glob.glob("%s/%s/*.yap" % (yapdir,comp)):
                files.append('\'%s\'' % yapfile)
            yapfiles=glob.glob("%s/%s/compiler/*.yap" % (yapdir,comp))
            yapfiles.sort()
            for yapfile in yapfiles:
                # if a loader is there, do not load it, to avoid double imports
                if not os.path.basename(yapfile)=="loader.yap": 
                    files.append('\'%s\'' % yapfile)
        for  solver in set(self._solvers.values()):
            for yapfile in glob.glob("%s/xmg/brick/%s/*.yap" % (yapdir,solver)):
                files.append('\'%s\'' % yapfile)
            for yapfile in glob.glob("%s/xmg/brick/%s/compiler/*.yap" % (yapdir,solver)):
                 # if a loader is there, do not load it, to avoid double imports
                if not os.path.basename(yapfile)=="loader.yap": 
                    files.append('\'%s\'' % yapfile)
        # compfile.write(", ".join(files))
        edcg_file='\''+yapdir+'/xmg/brick/mg/edcg.yap\''
        for a_file in files:
            if a_file==edcg_file:
                continue
            compfile.write(':-load_files([')
            compfile.write(a_file)
            compfile.write('],[silent(true)]).\n')
        print("Modules loader generated in %s/loader.yap"%self._folder)


    def generate_conf(self):
        compPath=os.getcwd()
        compSplit=compPath.split('/')
        compName=compSplit[len(compSplit)-1]
        conffile=open(self._folder+"/conf.yap","w")
        conffile.write('%% -*- prolog -*-\n\n')
        conffile.write(':-module(xmg_compiler_conf).\n\n')
        conffile.write('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n')
        conffile.write('%% Compiler Configuration\n')
        conffile.write('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n') 
        conffile.write('init:-\n')
        conffile.write('\tload_files([\'xmg/compiler/'+compName+'/' + self._parser_file + '\',\n')
        conffile.write('\t\'xmg/compiler/'+compName+'/generated/dimensions\',\n')
        conffile.write('\t\'xmg/compiler/'+compName+'/generated/tokenizer_punct\',\n')
        conffile.write('\t\'xmg/compiler/'+compName+'/generated/tokenizer_keywords\',\n')
        conffile.write('\t\'xmg/compiler/'+compName+'/generated/loader\',\n')
        conffile.write('\t\'xmg/compiler/'+compName+'/generated/solvers\'],[silent(true)]).\n\n')
        # conffile.write('\tuse_module(\'xmg/compiler/'+compName+'/' + self._parser_file + '\'),\n')
        # conffile.write('\tuse_module(\'xmg/compiler/'+compName+'/generated/dimensions\'),\n')
        # conffile.write('\tuse_module(\'xmg/compiler/'+compName+'/generated/tokenizer_punct\'),\n')
        # conffile.write('\tuse_module(\'xmg/compiler/'+compName+'/generated/tokenizer_keywords\'),\n')
        # conffile.write('\tuse_module(\'xmg/compiler/'+compName+'/generated/loader\'),\n')
        # conffile.write('\tuse_module(\'xmg/compiler/'+compName+'/generated/solvers\').\n\n')
        conffile.write('init_threads:-\n')
        conffile.write('\tuse_module(\'xmg/compiler/'+compName+'/generated/edcg\').')
        conffile.close()
        print("Configuration file generated in %s/conf.yap"%self._folder)

    def generate_parser(self,Brick):
        if self._parser_file is not None:
            #Brick.generate_parser(self._parser_file)
            Brick.language_brick.generate_parser(self._parser_file)
        else:
            raise Exception("No file set to generate the parser")

    def generate_emacs_mode(self):
        compPath=os.getcwd()
        compSplit=compPath.split('/')
        compName=compSplit[len(compSplit)-1]
        modefile=open(self._folder+"/emacs_mode","w")
        modefile.write(';;====================================================================\n')
        modefile.write(';; MetaGrammar mode, compiler '+compName+'\n')
        modefile.write(';; Automatically generated, based on the mode by B. Crabbe\n')
        modefile.write('(require \'generic-x)\n')
        modefile.write('(define-generic-mode \'metagrammar-mode\n') 
        modefile.write('  \'("%");;comments\n')
        modefile.write('  \'(')
        for key in self._keywords:
            modefile.write('"'+key+'"')
        modefile.write(');;keywords\n')
        modefile.write('  \'(\n')
        modefile.write('    ("class\\\\s (\*\*)* +\\\\(\\\\sw[a-zA-Z0-9_.-]*\\\\)" 1 \'font-lock-type-face);noms de classes\n')
        modefile.write('    ("\?[a-zA-Z0-9]+" . font-lock-variable-name-face)\n')
        modefile.write('    ("\![a-zA-Z0-9]+" . font-lock-constant-face)\n')
        modefile.write('    ("\<[a-zA-Z]+>" . font-lock-constant-face)\n')
        modefile.write('    ("\(\\\\(\\\\sw[a-zA-Z0-9_.-]*\\\\(,\\\\sw[a-zA-Z0-9_.-]*\\\\)*\\\\)\)" 1 font-lock-constant-face);;params & node props\n')
        modefile.write('    ("$\\\\(\\\\sw*\\\\)*" . font-lock-constant-face);;params inside\n')
        modefile.write('    )\n')
        modefile.write('  \'(".mg\\\\\'") ;;file extension\n')
        modefile.write('  nil\n')
        modefile.write('  "Major mode for metagrammar editing")  ')
        modefile.close()
        print("Emacs mode file generated in %s/emacs_mode"%self._folder)


        
    def generate_all(self):
        directory=self._folder
        if not os.path.exists(directory):
            os.makedirs(directory)            
        if directory is not None:
            self.generate_dimensions()
            self.generate_solvers()
            self.generate_tokenize_punctuation()
            self.generate_tokenize_keywords()
            self.generate_silent_loader()
            self.generate_edcg()
            self.generate_conf()
            self.generate_emacs_mode()
        else:
            raise Exception("No directory set for the compiler")

            
